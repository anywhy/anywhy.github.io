<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>咩咩杨 ( =•ω•= )</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://anywhy.xyz/"/>
  <updated>2019-10-25T01:39:50.096Z</updated>
  <id>http://anywhy.xyz/</id>
  
  <author>
    <name>Anywhy  ( =•ω•= )</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes CSI(Container Storage Interface) 开发文档</title>
    <link href="http://anywhy.xyz/posts/1079750075/"/>
    <id>http://anywhy.xyz/posts/1079750075/</id>
    <published>2019-10-24T11:44:55.000Z</published>
    <updated>2019-10-25T01:39:50.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文讲解了如何在Kubernetes上开发、部署和测试<a href="https://github.com/container-storage-interface/spec/blob/master/spec.md" target="_blank" rel="noopener">Container Storage Interface</a>(CSI)驱动程序。</p><p><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md" target="_blank" rel="noopener">Container Storage Interface</a>(CSI)是将任意块和文件存储系统暴露给容器编排系统(COs，如Kubernetes)上的容器化工作。使用CSI第三方存储提供商可以编写和部署在Kubernetes中暴露新存储系统的插件，而无需触及Kubernetes的核心代码。</p><h3 id="Kubernetes版本"><a href="#Kubernetes版本" class="headerlink" title="Kubernetes版本"></a>Kubernetes版本</h3><table><thead><tr><th>Kubernetes</th><th>CSI规范兼容</th><th>状态</th></tr></thead><tbody><tr><td>v1.9</td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.1.0" target="_blank" rel="noopener">v0.1.0</a></td><td>Alpha</td></tr><tr><td>v1.10</td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.2.0" target="_blank" rel="noopener">v0.2.0</a></td><td>Beta</td></tr><tr><td>v1.11</td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0" target="_blank" rel="noopener">v0.3.0</a></td><td>Beta</td></tr><tr><td>v1.13</td><td><a href="https://github.com/container-storage-interface/spec/releases/tag/v0.3.0" target="_blank" rel="noopener">v0.3.0</a>, <a href="https://github.com/container-storage-interface/spec/releases/tag/v1.0.0" target="_blank" rel="noopener">v1.0.0</a></td><td>GA</td></tr></tbody></table><a id="more"></a><h3 id="开发与部署"><a href="#开发与部署" class="headerlink" title="开发与部署"></a>开发与部署</h3><h4 id="最低要求-为Kubernetes开发和部署CSI驱动程序"><a href="#最低要求-为Kubernetes开发和部署CSI驱动程序" class="headerlink" title="最低要求(为Kubernetes开发和部署CSI驱动程序)"></a>最低要求(为Kubernetes开发和部署CSI驱动程序)</h4><p>Kubernetes尽可能少地规定了CSI卷驱动程序的打包和部署。唯一的需求是Kubernetes(Master和Node)组件如何查找和与CSI驱动程序通信。</p><p>具体来说，以下是Kubernetes关于CSI的描述:</p><ul><li>Kubelet与CSI通信：<ul><li>Kubelet通过UDS(Unix Domain Socket)直接向CSI驱动程序发出CSI调用(如<code>NodeStageVolume</code>、<code>NodePublishVolume</code>等)来挂载和卸载卷。</li><li>Kubelet通过<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins#device-plugin-registration" target="_blank" rel="noopener">Kubelet插件注册机制</a>发现CSI驱动程序(以及用于与CSI驱动程序交互的UDS)。</li><li>因此，部署在Kubernetes上的所有CSI驱动程序必须在每个Node上使用kubelet插件注册机制进行注册。</li></ul></li><li>Master与CSI驱动程序通信：<ul><li>Kubernetes主组件不直接(UDS或其他方式)与CSI驱动程序通信。</li><li>Kubernetes主组件只与Kubernetes API交互。</li><li>因此，需要依赖于Kubernetes API的操作的CSI驱动程序(如卷创建、卷附加、卷快照等)必须监视Kubernetes API并触发相应的CSI操作。</li></ul></li></ul><p>这些需求是最低限度的规定，CSI驱动程序开发人员可以自由地实现和部署他们认为合适的驱动程序。</p><blockquote><p>为了简化开发和部署，建议使用下面描述的机制。</p></blockquote><h4 id="推荐机制-用于开发和部署Kubernetes的CSI驱动程序"><a href="#推荐机制-用于开发和部署Kubernetes的CSI驱动程序" class="headerlink" title="推荐机制(用于开发和部署Kubernetes的CSI驱动程序)"></a>推荐机制(用于开发和部署Kubernetes的CSI驱动程序)</h4><p>Kubernetes开发团队已经建立了一个“推荐机制”来开发、部署和测试Kubernetes上的CSI驱动程序。它旨在减少样板代码和简化CSI驱动程序开发人员的整个过程。</p><p>“推荐机制”利用了以下组件:</p><ul><li>Kubernetes CSI <a href="https://github.com/kubernetes-csi/docs/blob/master/book/src/sidecar-containers.md" target="_blank" rel="noopener">边车(Sidecar)容器</a>。</li><li>Kubernetes CSI <a href="https://github.com/kubernetes-csi/docs/blob/master/book/src/csi-objects.md" target="_blank" rel="noopener">Objects</a>。</li><li>CSI驱动程序测试工具。</li></ul><p>要使用这种机制实现CSI驱动程序，CSI驱动程序开发人员应该:</p><ol><li><p>创建一个容器化的应用程序，实现CSI规范(CSI驱动程序容器)中描述的<code>Identity</code>、<code>Node</code>和可选的<code>Controller</code>服务。</p><ul><li>有关更多信息，请参见<a href="https://github.com/kubernetes-csi/docs/blob/master/book/src/developing.md" target="_blank" rel="noopener">开发CSI驱动程序</a>。</li></ul></li><li><p>使用CSI完整性对其进行单元测试。</p><ul><li>有关更多信息，请参见<a href="https://github.com/kubernetes-csi/docs/blob/master/book/src/unit-testing.md" target="_blank" rel="noopener">驱动程序单元测试</a>。</li></ul></li><li><p>定义Kubernetes API YAML文件，该文件部署CSI驱动程序容器和适当的边车(Sidecar)容器。</p><ul><li>有关更多信息，请参见在<a href="https://github.com/kubernetes-csi/docs/blob/master/book/src/deploying.md" target="_blank" rel="noopener">Kubernetes部署</a>。</li></ul></li><li><p>在Kubernetes集群上部署驱动程序，并在其上运行端到端的功能测试。</p><ul><li>参见<a href="https://github.com/kubernetes-csi/docs/blob/master/book/src/functional-testing.md" target="_blank" rel="noopener">驱动程序-功能测试</a>。</li></ul></li></ol><h2 id="为Kubernetes开发CSI驱动程序"><a href="#为Kubernetes开发CSI驱动程序" class="headerlink" title="为Kubernetes开发CSI驱动程序"></a>为Kubernetes开发CSI驱动程序</h2><p>创建CSI驱动程序的第一步是编写实现CSI规范中描述的gRPC服务的应用程序。</p><p>至少，CSI驱动程序必须实现下列CSI接口服务:</p><ul><li>CSI<code>Identity</code>服务<ul><li>允许调用者(Kubernetes组件和CSI边车(Sidecar)容器)识别驱动程序及其支持的可选功能。</li></ul></li><li>CSI<code>Node</code>服务<ul><li>只需要<code>NodePublishVolume</code>、<code>NodeUnpublishVolume</code>和<code>NodeGetCapabilities</code>。</li><li>所需的方法使调用方能够在指定的路径上使卷可用，并发现驱动程序支持哪些可选功能。</li></ul></li></ul><p>所有CSI服务可以在同一个CSI驱动程序应用程序中实现。CSI驱动程序应用程序应该被封装起来，以便于部署到Kubernetes上。一旦容器部署后，CSI驱动程序就可以与CSI<a href="https://kubernetes-csi.github.io/docs/sidecar-containers.html" target="_blank" rel="noopener">边车(Sidecar)容器</a>配对，并在适当的情况下部署在节点或z着成为控制器(Controller)服务。</p><h3 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h3><p>如果你的驱动支持附加功能，CSI“Capabilities”可以用来说明它支持的可选方法/服务，例如:</p><ul><li><code>CONTROLLER_SERVICE</code> (<code>PluginCapability</code>)<ul><li>整个CSI<code>控制器(Controller)</code>服务是可选的。此功能指示驱动程序实现CSI<code>控制器(Controller)</code>服务中的一个或多个方法。</li></ul></li><li><code>VOLUME_ACCESSIBILITY_CONSTRAINTS</code> (<code>PluginCapability</code>)<ul><li>此功能表明此驱动程序的卷可能无法从集群中的所有节点平等地访问，并且驱动程序将返回与拓扑相关的附加信息，Kubernetes可以使用这些信息来更智能地调度工作负载，或影响卷的供应位置。</li></ul></li><li><code>VolumeExpansion</code> (<code>PluginCapability</code>)<ul><li>此功能表明驱动程序支持在创建后调整(扩展)卷。</li></ul></li><li><code>CREATE_DELETE_VOLUME</code> (<code>ControllerServiceCapability</code>)<ul><li>此功能表明驱动程序支持动态卷挂载和卸载。</li></ul></li><li><code>PUBLISH_UNPUBLISH_VOLUME</code> (<code>ControllerServiceCapability</code>)<ul><li>此功能指示驱动程序实现<code>ControllerPublishVolume</code>和<code>ControllerUnpublishVolume</code>这些操作对应于Kubernetes卷附加/分离操操作。例如，这可能导致对谷歌云控制平面执行<code>volume attach</code>操作，将指定的卷附加到谷歌Cloud PD CSI驱动程序的指定节点。</li></ul></li><li><code>CREATE_DELETE_SNAPSHOT</code> (<code>ControllerServiceCapability</code>)<ul><li>此功能表明驱动程序支持供应卷快照，并支持使用这些快照供应新卷。</li></ul></li><li><code>CLONE_VOLUME</code> (<code>ControllerServiceCapability</code>)<ul><li>此功能表明驱动程序支持克隆卷。</li></ul></li><li><code>STAGE_UNSTAGE_VOLUME</code> (<code>NodeServiceCapability</code>)<ul><li>这个能力表明驱动程序实现了<code>NodeStageVolume</code>和<code>NodeUnstageVolume</code>这些操作对应于Kubernetes卷设备的挂载/卸载操作。例如，这可以用于创建块存储设备的全局(每个节点)卷挂载。<br>这是一个部分列表，请参阅<a href="https://github.com/container-storage-interface/spec/blob/master/spec.md" target="_blank" rel="noopener">CSI规范</a>中的完整功能列表。</li></ul></li></ul><h3 id="Kubernetes-CSI边车-Sidecar-容器"><a href="#Kubernetes-CSI边车-Sidecar-容器" class="headerlink" title="Kubernetes CSI边车(Sidecar)容器"></a>Kubernetes CSI边车(Sidecar)容器</h3><p>Kubernetes CSI边车(Sidecar)容器是一套标准容器，旨在简化在Kubernetes上开发和部署CSI驱动程序。</p><p>这些容器包含监视Kubernetes API的通用逻辑，触发针对“CSI卷驱动程序”容器的适当操作，并根据需要更新Kubernetes API。</p><p>这些容器将与第三方CSI驱动容器捆绑在一起，并作为POD一起部署。</p><p>这些容器由Kubernetes存储社区开发和维护。</p><blockquote><p>使用容器是严格可选的，但强烈建议使用。</p></blockquote><p>使用边车(Sidecar)容器的好处包括:</p><ul><li>减少“引用”代码。<ul><li>CSI驱动程序开发者不必担心复杂的“Kubernetes专用”代码。</li></ul></li><li>代码隔离<ul><li>与Kubernetes API交互的代码与实现CSI接口的代码隔离(然后在不同的容器中)。</li></ul></li></ul><p>Kubernetes开发团队维护以下Kubernetes CSI边车(Sidecar)容器:</p><ul><li><a href="https://kubernetes-csi.github.io/docs/external-provisioner.html" target="_blank" rel="noopener">external-provisioner</a></li><li><a href="https://kubernetes-csi.github.io/docs/external-attacher.html" target="_blank" rel="noopener">external-attacher</a></li><li><a href="https://kubernetes-csi.github.io/docs/external-snapshotter.html" target="_blank" rel="noopener">external-snapshotter</a></li><li><a href="https://kubernetes-csi.github.io/docs/external-resizer.html" target="_blank" rel="noopener">external-resizer</a></li><li><a href="https://kubernetes-csi.github.io/docs/node-driver-registrar.html" target="_blank" rel="noopener">node-driver-registrar</a></li><li><a href="https://kubernetes-csi.github.io/docs/cluster-driver-registrar.html" target="_blank" rel="noopener">cluster-driver-registrar</a> (废弃)</li><li><a href="https://kubernetes-csi.github.io/docs/livenessprobe.html" target="_blank" rel="noopener">livenessprobe</a></li></ul><h2 id="CSI-Objects"><a href="#CSI-Objects" class="headerlink" title="CSI Objects"></a>CSI Objects</h2><p>状态: Beta<br>Kubernetes API包含以下CSI特定对象:</p><ul><li>CSIDriver Object</li><li>CSINode Object</li></ul><p>两者都是<code>storage.k8s.io/v1beta1</code> API的部分。</p><p>对象的模式定义可以在这里找到:<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/storage/types.go" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/storage/types.go</a></p><h3 id="CSIDriver-Object"><a href="#CSIDriver-Object" class="headerlink" title="CSIDriver Object"></a>CSIDriver Object</h3><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><ul><li>Kubernetes 1.12 - 1.13: Alpha</li><li>Kubernetes 1.14: Beta</li></ul><h4 id="什么是-CSIDriver-Object"><a href="#什么是-CSIDriver-Object" class="headerlink" title="什么是 CSIDriver Object"></a>什么是 CSIDriver Object</h4><p><code>CSIDriver</code> Kubernetes API对象有两个用途:</p><ol><li>简化驱动发现<ul><li>如果CSI驱动程序创建了CSIDriver对象，Kubernetes用户可以很容易地发现安装在其集群上的CSI驱动程序(只需发出<code>kubectl get CSIDriver</code>)</li></ul></li><li>定制Kubernetes行为<ul><li>Kubernetes在处理CSI驱动程序时有一组默认的行为(例如，它默认调用附加/分离操作)。这个对象允许CSI驱动程序指定Kubernetes如何与之交互。</li></ul></li></ol><h4 id="CSIDriver-对象属性"><a href="#CSIDriver-对象属性" class="headerlink" title="CSIDriver 对象属性"></a>CSIDriver 对象属性</h4><p>下面是一个v1beta1 <code>CSIDriver</code>对象的例子:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CSIDriver</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">mycsidriver.example.com</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">attachRequired:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">podInfoOnMount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">volumeLifecycleModes:</span> <span class="comment"># added in Kubernetes 1.16</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Persistent</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Ephemeral</span></span><br></pre></td></tr></table></figure><p>有三个重要的字段:</p><ul><li><code>name</code><ul><li>他的名字应该与CSI驱动程序的全名对应。</li></ul></li><li><code>attachRequired</code><ul><li>指示此CSI卷驱动程序需要附加操作(因为它实现了CSI <code>ControllerPublishVolume</code>方法)，并且Kubernetes应该调用附加并等待任何附加操作完成后再继续挂载。</li><li>如果给定的CSI驱动程序不存在<code>CSIDriver</code>对象，则默认值为<code>true</code>,这意味着将调用<code>attach</code>。</li><li>如果给定的CSI驱动程序存在<code>CSIDriver</code>对象，但是没有指定该字段，那么它也默认为<code>true</code>,这意味着将调用<code>attach</code>。<br>有关更多信息，请参见<a href="https://kubernetes-csi.github.io/docs/skip-attach.html" target="_blank" rel="noopener">Skip Attach</a>。</li></ul></li><li><code>podInfoOnMount</code><ul><li>指示此CSI卷驱动程序在安装操作期间需要附加的pod信息(如pod名称、pod UID等)。</li><li>如果未指定值或为<code>false</code>，将不会在挂载上传递pod信息。</li><li>如果值设置为<code>true</code>, Kubelet将在CSI <code>NodePublishVolume</code>中以<code>volume_context</code>的形式传递pod信息:<ul><li><code>&quot;csi.storage.k8s.io/pod.name&quot;: pod.Name</code></li><li><code>&quot;csi.storage.k8s.io/pod.namespace&quot;: pod.Namespace</code></li><li><code>&quot;csi.storage.k8s.io/pod.uid&quot;: string(pod.UID)</code></li></ul></li><li>有关更多信息，请参见<a href="https://kubernetes-csi.github.io/docs/pod-info.html" target="_blank" rel="noopener">POD挂载信息</a>。</li></ul></li><li><code>volumeLifecycleModes</code><ul><li>这个字段是在Kubernetes 1.16中添加的，在使用较老的Kubernetes版本时无法设置。</li><li>它通知Kubernetes有关驱动程序支持的降级模式。这可以确保用户没有错误地使用驱动程序。默认值是<code>Persistent</code>，这是常规的PVC/PV机制。此外，<code>Ephemeral</code>还支持<a href="https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html" target="_blank" rel="noopener">inline ephemeral volumes</a>(当两者都被列出时)或代替普通卷(当它是列表中唯一的一个条目时)。</li></ul></li></ul><h4 id="是什么创建了CSIDriver对象"><a href="#是什么创建了CSIDriver对象" class="headerlink" title="是什么创建了CSIDriver对象"></a>是什么创建了CSIDriver对象</h4><p>要安装，CSI驱动程序的部署清单必须包含如上例所示的CSIDriver对象。</p><blockquote><p>注意:Kubernetes 1.13中用于创建CSIDriver对象的cluster-driver-registrar边车(Sidecar)容器已经被Kubernetes 1.16所弃用。Kubernetes 1.14及以后版本还没有发布集群驱动程序注册表。</p></blockquote><p><code>CSIDriver</code>实例应该存在于所有使用相应的CSI驱动程序提供的卷的POD整个生命周期中，所以<a href="https://github.com/kubernetes-csi/docs/blob/master/book/src/skip-attach.md" target="_blank" rel="noopener">Skip Attach</a>和<a href="https://github.com/kubernetes-csi/docs/blob/master/book/src/pod-info.md" target="_blank" rel="noopener">Pod Info on Mount</a>可以正确工作。</p><h4 id="查看CSDriver注册清单"><a href="#查看CSDriver注册清单" class="headerlink" title="查看CSDriver注册清单"></a>查看CSDriver注册清单</h4><p>使用CSIDriver对象，现在可以查询Kubernetes来获得在集群中运行的注册驱动程序列表，如下所示:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&gt; kubectl get csidrivers.storage.k8s.io</span><br><span class="line">NAME                  CREATED AT</span><br><span class="line">hostpath.csi.k8s.io   2019-09-13T09:58:43Z</span><br></pre></td></tr></table></figure><p>或着取得更详细的信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&gt; kubectl describe csidrivers.storage.k8s.io</span><br><span class="line">Name:         hostpath.csi.k8s.io</span><br><span class="line">Namespace:    </span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubectl.kubernetes.io/last-applied-configuration:</span><br><span class="line">                &#123;"apiVersion":"storage.k8s.io/v1beta1","kind":"CSIDriver","metadata":&#123;"annotations":&#123;&#125;,"name":"hostpath.csi.k8s.io"&#125;,"spec":&#123;"podInfoOnMou...</span><br><span class="line">API Version:  storage.k8s.io/v1beta1</span><br><span class="line">Kind:         CSIDriver</span><br><span class="line">Metadata:</span><br><span class="line">  Creation Timestamp:  2019-09-13T09:58:43Z</span><br><span class="line">  Resource Version:    341</span><br><span class="line">  Self Link:           /apis/storage.k8s.io/v1beta1/csidrivers/hostpath.csi.k8s.io</span><br><span class="line">  UID:                 1860f2a1-85f8-4357-a933-c45e54f0c8e0</span><br><span class="line">Spec:</span><br><span class="line">  Attach Required:    true</span><br><span class="line">  Pod Info On Mount:  true</span><br><span class="line">  Volume Lifecycle Modes:</span><br><span class="line">    Persistent</span><br><span class="line">    Ephemeral</span><br><span class="line">Events:  &lt;none&gt;</span><br></pre></td></tr></table></figure><h4 id="Alpha-to-Beta版本的变化"><a href="#Alpha-to-Beta版本的变化" class="headerlink" title="Alpha to Beta版本的变化"></a>Alpha to Beta版本的变化</h4><p>在开发过程中，CSIDriver对象也被定义为自定义资源定义(CRD)。作为升级到beta的一部分，该对象已被移动到内置的Kubernetes API。</p><p>在从alpha迁移到beta的过程中，该对象的API组从<code>csi.storage.k8s.io/v1alpha1</code>更改为<code>storage.k8s.io/v1beta1</code>。</p><p>在Kubernetes更新到新的内置类型时，不会自动更新现有的CRD及其CRs。</p><h4 id="Kubernetes启用CSIDriver"><a href="#Kubernetes启用CSIDriver" class="headerlink" title="Kubernetes启用CSIDriver"></a>Kubernetes启用CSIDriver</h4><p>在Kubernetes v1.12和v1.13中，因为这个特性是alpha版本，所以默认情况下是禁用的。要在这些版本中使用CSIDriver，请执行以下操作:</p><ol><li>通过以下Kubernetes特性标志确保启用特性门: <code>--feature-gates=CSIDriverRegistry=true</code></li><li>要么通过Kubernetes存储CRD插件确保CSIDriver CRD是自动安装的，要么使用以下命令在Kubernetes集群上手动安装CSIDriver CRD:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&gt; kubectl create -f https://raw.githubusercontent.com/kubernetes/csi-api/master/pkg/crd/manifests/csidriver.yaml</span><br></pre></td></tr></table></figure><p>Kubernetes v1.14+使用了相同的Kubernetes特性标志，但是由于该特性是beta版，所以默认启用了它。由于API类型(从beta版开始)内建在Kubernetes API中，因此不再需要安装CRD。</p><h3 id="CSINode-Object"><a href="#CSINode-Object" class="headerlink" title="CSINode Object"></a>CSINode Object</h3><h4 id="状态-1"><a href="#状态-1" class="headerlink" title="状态"></a>状态</h4><ul><li>Kubernetes 1.12 - 1.13: Alpha</li><li>Kubernetes 1.14: Beta</li></ul><h4 id="什么是-CSINode-Object"><a href="#什么是-CSINode-Object" class="headerlink" title="什么是 CSINode Object"></a>什么是 CSINode Object</h4><p>CSI驱动程序生成特定于节点的信息。不是将其存储在Kubernetes节点API对象中，而是创建了一个新的CSI特定的Kubernetes CSINode对象。</p><p>它的用途如下:</p><ol><li>Kubernetes Node name 和 CSI Node name之间的映射</li></ol><ul><li>CSI <code>GetNodeInfo</code>调用返回存储系统引用节点的名称。Kubernetes必须在将来的<code>ControllerPublishVolume</code>调用中使用这个名称。因此，当注册一个新的CSI驱动程序时，Kubernetes将存储系统节点ID存储在<code>CSINode</code>对象中，以供将来参考。</li></ul><ol start="2"><li>驱动程序可用性</li></ol><ul><li>kubelet与kube-controller-manager和kubernetes调度器通信的一种方式，不管驱动程序在节点上是否可用(已注册)。</li></ul><ol start="3"><li>卷的拓扑</li></ol><ul><li>CSI <code>GetNodeInfo</code>调用返回一组标识该节点拓扑结构的键/值标签。Kubernetes使用这些信息进行拓扑感知供应(有关详细信息，请参阅PVC卷绑定模式)。它将键/值作为标签存储在Kubernetes节点对象上。为了回忆起哪个节点标签键属于一个特定的CSI驱动程序，kubelet将这些键存储在<code>CSINode</code>对象中以供将来参考。</li></ul><h4 id="CSINode-对象属性"><a href="#CSINode-对象属性" class="headerlink" title="CSINode 对象属性"></a>CSINode 对象属性</h4><p>下面是一个v1beta1 <code>CSINode</code>对象的例子:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CSINodeInfo</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">node1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  drivers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">mycsidriver.example.com</span></span><br><span class="line"><span class="attr">    nodeID:</span> <span class="string">storageNodeID1</span></span><br><span class="line"><span class="attr">    topologyKeys:</span> <span class="string">['mycsidriver.example.com/regions',</span> <span class="string">"mycsidriver.example.com/zones"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p>字段的含义：</p><ul><li><code>drivers</code>- 运行在节点上的CSI驱动程序及其属性列表。</li><li><code>name</code> - 此对象引用的CSI驱动程序。</li><li><code>nodeID</code> - 由驱动程序确定的节点的指定标识符。</li><li><code>topologyKeys</code> - 驱动程序支持的分配给节点的拓扑密钥列表。</li></ul><h4 id="是什么创建了CSINode对象"><a href="#是什么创建了CSINode对象" class="headerlink" title="是什么创建了CSINode对象"></a>是什么创建了CSINode对象</h4><p>CSI驱动程序不需要直接创建<code>CSINode</code>对象。相反，它们应该使用<code>node-driver-registrar</code>边车(Sidecar)容器。这个边车(Sidecar)容器将通过kubelet插件注册机制与kubelet交互，代表CSI驱动程序自动填充<code>CSINode</code>对象。</p><h4 id="Alpha-to-Beta版本的变化-1"><a href="#Alpha-to-Beta版本的变化-1" class="headerlink" title="Alpha to Beta版本的变化"></a>Alpha to Beta版本的变化</h4><p>alpha对象称为<code>CSINodeInfo</code>，而beta对象称为<code>CSINode</code>。alpha <code>CSINodeInfo</code>对象也被定义为自定义资源定义(CRD)。作为升级到beta的一部分，该对象已被移动到内置的Kubernetes API。</p><p>在从alpha迁移到beta的过程中，该对象的API组从<code>csi.storage.k8s.io/v1alpha1</code>更改为<code>csi.storage.k8s.io/v1beta1</code>。</p><p>在Kubernetes更新到新的内置类型时，不会自动更新现有的CRD及其CRs。</p><h4 id="Kubernetes启用CSIDriver-1"><a href="#Kubernetes启用CSIDriver-1" class="headerlink" title="Kubernetes启用CSIDriver"></a>Kubernetes启用CSIDriver</h4><p>在Kubernetes v1.12和v1.13中，因为这个特性是alpha版本，所以默认情况下是禁用的。要在这些版本中使用CSINodeInfo，请执行以下操作:</p><ol><li>确保使用<code>--features-gates=CSINodeInfo=true</code>启用功能。</li><li>要么通过Kubernetes存储CRD插件确保<code>CSIDriver</code>CRD是自动安装的，要么使用以下命令在Kubernetes集群上手动安装<code>CSINodeInfo</code>CRD:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&gt; kubectl create -f https://raw.githubusercontent.com/kubernetes/csi-api/master/pkg/crd/manifests/csinodeinfo.yaml</span><br></pre></td></tr></table></figure><p>Kubernetes v1.14+使用了相同的Kubernetes特性标志，但是由于该特性是beta版，所以默认启用了它。由于API类型(从beta版开始)内建在Kubernetes API中，因此不再需要安装CRD。</p><h3 id="Kubernetes上安装CSI插件"><a href="#Kubernetes上安装CSI插件" class="headerlink" title="Kubernetes上安装CSI插件"></a>Kubernetes上安装CSI插件</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>CSI驱动程序通常作为两个组件部署在Kubernetes中:控制器组件和每个节点组件。</p><h4 id="Controller-插件"><a href="#Controller-插件" class="headerlink" title="Controller 插件"></a>Controller 插件</h4><p>控制器组件可以作为部署或状态集部署在集群中的任何节点上。它由实现CSI控制器服务的CSI驱动程序和一个或多个边车(Sidecar)容器组成。这些控制器边车(Sidecar)容器通常与Kubernetes对象交互，并调用驱动程序的CSI控制器服务。</p><p>它通常不需要直接访问主机，可以通过Kubernetes API和外部控制平面服务执行所有操作。可以为HA部署控制器组件的多个副本，但是建议使用leader election来确保一次只有一个活动控制器。</p><p>控制器(Sidecar)容器包含<code>external-provisioner</code>,<code>external-attacher</code>,<code>external-snapshotter</code>和<code>external-resizer</code>。 在部署中包含一个边车(Sidecar)容器是可选的。</p><h5 id="与边车-Sidecar-通信"><a href="#与边车-Sidecar-通信" class="headerlink" title="与边车(Sidecar)通信"></a>与边车(Sidecar)通信</h5><p><img src="sidecar-container.png?raw=true" alt="CSI Controller Deployment Diagram" title="CSI Controller Deployment Diagram"></p><p>边车(Sidecar)容器管理Kubernetes事件并适当地调用CSI驱动程序。调用是通过边车(Sidecars)容器和CSI驱动程序之间的emptyDir卷共享一个UDS进行的。</p><h5 id="RBAC-策略"><a href="#RBAC-策略" class="headerlink" title="RBAC 策略"></a>RBAC 策略</h5><p>大多数控制器边车与Kubernetes对象交互，因此需要设置RBAC策略。每个sidecar存储库都包含示例RBAC配置。</p><h4 id="Node-插件"><a href="#Node-插件" class="headerlink" title="Node 插件"></a>Node 插件</h4><p>节点组件应该通过一个守护进程部署在集群中的每个节点上。它由实现CSI节点服务的CSI驱动程序和node-driver-registrar边车(Sidecar)容器组成。</p><h5 id="与Kubelet通信"><a href="#与Kubelet通信" class="headerlink" title="与Kubelet通信"></a>与Kubelet通信</h5><p><img src="kubelet.png?raw=true" alt="CSI Node Deployment Diagram" title="CSI Node Deployment Diagram"></p><p>Kubernetes kubelet在每个节点上运行，负责发出CSI节点服务调用。这些调用从存储系统挂载和卸载存储卷，使之可供Pod使用。Kubelet通过主机上通过主机路径卷共享的UDS调用CSI驱动程序。node-driver-registrar还使用第二个UDS将CSI驱动程序注册到kubelet。</p><h4 id="驱动卷挂载"><a href="#驱动卷挂载" class="headerlink" title="驱动卷挂载"></a>驱动卷挂载</h4><p>节点插件需要直接访问主机，以使块设备和/或文件系统安装对Kubernetes kubelet可用。</p><p>CSI驱动程序使用的挂载点必须设置为双向，以允许主机上的Kubelet看到CSI驱动程序容器创建的挂载。请看下面的例子:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">my-csi-driver</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"><span class="attr">  volumeMounts:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">socket-dir</span></span><br><span class="line"><span class="attr">    mountPath:</span> <span class="string">/csi</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">mountpoint-dir</span></span><br><span class="line"><span class="attr">    mountPath:</span> <span class="string">/var/lib/kubelet/pods</span></span><br><span class="line"><span class="attr">    mountPropagation:</span> <span class="string">"Bidirectional"</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">node-driver-registrar</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"><span class="attr">  volumeMounts:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">registration-dir</span></span><br><span class="line"><span class="attr">    mountPath:</span> <span class="string">/registration</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="comment"># This volume is where the socket for kubelet-&gt;driver communication is done</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">socket-dir</span></span><br><span class="line"><span class="attr">  hostPath:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/var/lib/kubelet/plugins/&lt;driver-name&gt;</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line"><span class="comment"># This volume is where the driver mounts volumes</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">mountpoint-dir</span></span><br><span class="line"><span class="attr">  hostPath:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/var/lib/kubelet/pods</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Directory</span></span><br><span class="line"><span class="comment"># This volume is where the node-driver-registrar registers the plugin</span></span><br><span class="line"><span class="comment"># with kubelet</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">registration-dir</span></span><br><span class="line"><span class="attr">  hostPath:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/var/lib/kubelet/plugins_registry</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Directory</span></span><br></pre></td></tr></table></figure><h4 id="启用特权POD"><a href="#启用特权POD" class="headerlink" title="启用特权POD"></a>启用特权POD</h4><p>要使用CSI驱动程序，Kubernetes集群必须允许特权pod(即API服务器和kubelet必须将–allow-privileged标志设置为true)。这是某些环境(例如GCE、GKE、kubeadm)的默认设置。</p><p>确保你的API服务器启动与特权标志:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./kube-apiserver ...  --allow-privileged=true ...</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./kubelet ...  --allow-privileged=true ...</span><br></pre></td></tr></table></figure><blockquote><p>注意:从Kubernetes 1.13.0开始，——对kubelet来说允许特权是正确的。在未来的kubernetes版本中，它将被弃用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本文讲解了如何在Kubernetes上开发、部署和测试&lt;a href=&quot;https://github.com/container-storage-interface/spec/blob/master/spec.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Container Storage Interface&lt;/a&gt;(CSI)驱动程序。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/container-storage-interface/spec/blob/master/spec.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Container Storage Interface&lt;/a&gt;(CSI)是将任意块和文件存储系统暴露给容器编排系统(COs，如Kubernetes)上的容器化工作。使用CSI第三方存储提供商可以编写和部署在Kubernetes中暴露新存储系统的插件，而无需触及Kubernetes的核心代码。&lt;/p&gt;
&lt;h3 id=&quot;Kubernetes版本&quot;&gt;&lt;a href=&quot;#Kubernetes版本&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes版本&quot;&gt;&lt;/a&gt;Kubernetes版本&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Kubernetes&lt;/th&gt;
&lt;th&gt;CSI规范兼容&lt;/th&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;v1.9&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/container-storage-interface/spec/releases/tag/v0.1.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v0.1.0&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Alpha&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1.10&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/container-storage-interface/spec/releases/tag/v0.2.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v0.2.0&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Beta&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1.11&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/container-storage-interface/spec/releases/tag/v0.3.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v0.3.0&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Beta&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1.13&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/container-storage-interface/spec/releases/tag/v0.3.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v0.3.0&lt;/a&gt;, &lt;a href=&quot;https://github.com/container-storage-interface/spec/releases/tag/v1.0.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v1.0.0&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;GA&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://anywhy.xyz/categories/Kubernetes/"/>
    
    
      <category term="CSI" scheme="http://anywhy.xyz/tags/CSI/"/>
    
      <category term="Kubernetes" scheme="http://anywhy.xyz/tags/Kubernetes/"/>
    
      <category term="storage" scheme="http://anywhy.xyz/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>Java CAS 原理解析</title>
    <link href="http://anywhy.xyz/posts/485786759/"/>
    <id>http://anywhy.xyz/posts/485786759/</id>
    <published>2019-10-16T12:32:29.000Z</published>
    <updated>2019-10-25T01:39:50.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CAS操作原理分析"><a href="#CAS操作原理分析" class="headerlink" title="CAS操作原理分析"></a>CAS操作原理分析</h2><p>CAS:Compare and Swap, 翻译成比较并交换。<br>在Java中，<code>java.util.concurrent</code>包中借助了CAS实现了线程同步的一种乐观锁，区别于<code>synchronized</code>（悲观锁），不会导致需要锁的线程都挂起。</p><p>在Java中也提供了这种操作类，例如：</p><ul><li>AtomicBoolean</li><li>AtomicInteger</li></ul><a id="more"></a><p>具体如何使用呢？看个小小的demo，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自增 1并返回之后的结果</span></span><br><span class="line">        ai.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CAS-原理"><a href="#CAS-原理" class="headerlink" title="CAS 原理"></a>CAS 原理</h3><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。CAS采用的是一种非阻塞算法（nonblocking algorithms），一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。在Java中是通过调用JNI实现的。</p><p>例如上述demo中<code>AtomicInteger</code>实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     ......</span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="comment">// 调用JNI的辅助类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 定义了volatile类型变量</span></span><br><span class="line">     <span class="comment">// 通过volatile关键字来保证多线程间数据的可见性的, 在没有锁的机制下可能需要借助volatile原语，保证线程间的数据是可见的（共享的）。这样才获取变量的值的时候才能直接读取。</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">     .....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用JNI来完成CPU指令的操作</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在上述实现用<code>unsafe.compareAndSwapInt</code>通过JNI调用了底层系统CUP指令实现原子性操作。</p><ul><li><p>代码片段如下：</p><pre><code class="c"><span class="comment">// Adding a lock prefix to an instruction on MP machine</span><span class="comment">// VC++ doesn't like the lock prefix to be on a single line</span><span class="comment">// so we can't insert a label after the lock prefix.</span><span class="comment">// By emitting a lock prefix, we can define a label after it.</span><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) __asm cmp mp, 0  \</span>                    __asm je L0      \                    __asm _emit <span class="number">0xF0</span> \                    __asm L0:<span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) {<span class="comment">// alternative for InterlockedCompareExchange</span><span class="keyword">int</span> mp = os::is_MP();__asm {    mov edx, dest    mov ecx, exchange_value    mov eax, compare_value    LOCK_IF_MP(mp)    cmpxchg dword ptr [edx], ecx}}</code></pre></li><li><p><code>cmpxchg</code> 是汇编指令，用于比较并交换操作数。根据CPU处理器源代码所示，程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（lock cmpxchg）。反之，如果程序是在单处理器上运行，就省略lock前缀（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障效果）。</p></li></ul></li></ul><h2 id="CAS可能出现的问题-ABA"><a href="#CAS可能出现的问题-ABA" class="headerlink" title="CAS可能出现的问题(ABA)"></a>CAS可能出现的问题(ABA)</h2><p>虽然这种 CAS 的机制能够保证increment() 方法，但依然有一些问题，例如，当线程A即将要执行第三步的时候，线程 B 把 i 的值加1，之后又马上把 i 的值减 1，然后，线程 A 执行第三步，这个时候线程 A 是认为并没有人修改过 i 的值，因为 i 的值并没有发生改变。而这，就是我们平常说的<code>ABA</code>问题。<br>对于基本类型的值来说，这种把数字改变了在改回原来的值是没有太大影响的，但如果是对于引用类型的话，就会产生很大的影响了。</p><p>如何解决ABA？<br>为了解决这个 ABA 的问题，我们可以引入版本控制，例如，每次有线程修改了引用的值，就会进行版本的更新，虽然两个线程持有相同的引用，但他们的版本不同，这样，我们就可以预防 <code>ABA</code> 问题了。Java 中提供了 AtomicStampedReference 这个类，就可以进行版本控制了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CAS操作原理分析&quot;&gt;&lt;a href=&quot;#CAS操作原理分析&quot; class=&quot;headerlink&quot; title=&quot;CAS操作原理分析&quot;&gt;&lt;/a&gt;CAS操作原理分析&lt;/h2&gt;&lt;p&gt;CAS:Compare and Swap, 翻译成比较并交换。&lt;br&gt;在Java中，&lt;code&gt;java.util.concurrent&lt;/code&gt;包中借助了CAS实现了线程同步的一种乐观锁，区别于&lt;code&gt;synchronized&lt;/code&gt;（悲观锁），不会导致需要锁的线程都挂起。&lt;/p&gt;
&lt;p&gt;在Java中也提供了这种操作类，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AtomicBoolean&lt;/li&gt;
&lt;li&gt;AtomicInteger&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://anywhy.xyz/categories/Java/"/>
    
    
      <category term="Java" scheme="http://anywhy.xyz/tags/Java/"/>
    
      <category term="CAS" scheme="http://anywhy.xyz/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes CSI(Container Storage Interface) 设计文档</title>
    <link href="http://anywhy.xyz/posts/2603569835/"/>
    <id>http://anywhy.xyz/posts/2603569835/</id>
    <published>2019-10-12T11:21:08.000Z</published>
    <updated>2019-10-25T01:39:50.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSI-Volume-Plugins-in-Kubernetes-Design-Doc"><a href="#CSI-Volume-Plugins-in-Kubernetes-Design-Doc" class="headerlink" title="CSI Volume Plugins in Kubernetes Design Doc"></a>CSI Volume Plugins in Kubernetes Design Doc</h2><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><table><thead><tr><th>术语</th><th>解析</th></tr></thead><tbody><tr><td>Container Storage Interface (CSI)</td><td>一种试图建立行业标准接口的规范，容器编排系统(COs)可以用来将任意存储系统暴露给它们的容器化工作负载。</td></tr><tr><td>in-tree</td><td>Kubernetes 核心代码库中的代码。</td></tr><tr><td>out-of-tree</td><td>Kubernetes 核心代码库之外的代码。</td></tr><tr><td>CSI Volume Plugin</td><td>核心代码库中一个新的volume插件，用作适配器，支持第三方Kubernetes CSI volume驱动程序。</td></tr><tr><td>CSI Volume Driver</td><td>第三方CSI插件驱动实现，可以用过CSI Volume Plugin在Kubernetes中使用。</td></tr></tbody></table><a id="more"></a><h2 id="背景-amp-动机"><a href="#背景-amp-动机" class="headerlink" title="背景&amp;动机"></a>背景&amp;动机</h2><p>Kubernetes volume 插件当前是“in-tree”方式实现，这样意味着它们与核心库本内二进制文件链接、编译、构建和交付。 向Kubernes(volume)添加新的存储系统需要将需改Kubernes核心代码库。这是不可取的，原因有很多，包括:</p><ol><li>Volume插件发布是一个紧密的过程而且依赖于Kubernetes releases版本。</li><li>Kubernetes开发人员/社区负责测试和维护所有卷插件，而不仅仅是测试和维护稳定的插件应用编程接口。</li><li>Volume插件中的错误会导致关键的Kubernetes组件崩溃，而不仅仅是插件。 </li><li>Volume插件获得Kubernetes组件(kubelet和kube-controller-manager)的完全权限。</li><li>插件开发人员被迫提供插件源代码，不能选择只发布可执行包。</li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为了支持CSI兼容卷插件，Kubernetes将引入一个新的树内CSI卷插件。这个新的Volume插件将成为Kubernetes用户(应用程序开发人员和集群管理员)与外部CSI卷驱动程序交互的机制。</p><p>对新的<code>in-tree</code>CSI卷插件的<code>设置</code>/<code>拆卸</code>调用将通过节点计算机上的unix domain socket(UDS)直接调用<code>NodePublishVolume</code>和<code>NodeUnpublishVolume</code>CSI RPCs。</p><p>提供/删除和附加/分离必须由某个外部组件来处理，该组件代表CSI卷驱动程序监视Kubernetes API，并调用适当的CSI RPCs接口。</p><p>为了简化集成，Kubernetes团队将提供一个容器来捕获所有Kubernetes特定的逻辑，并充当第三方容器化CSI卷驱动程序和Kubernetes之间的适配器(CSI驱动程序的每个部署都有自己的适配器实例)。</p><h2 id="设计详情"><a href="#设计详情" class="headerlink" title="设计详情"></a>设计详情</h2><h3 id="第三方-CSI-Volume-Drivers"><a href="#第三方-CSI-Volume-Drivers" class="headerlink" title="第三方 CSI Volume Drivers"></a>第三方 CSI Volume Drivers</h3><p>Kubernetes对CSI卷驱动程序的打包和部署尽可能不严格。使用通信信道(记录在下面)是在Kubernetes启用任意外部CSI兼容存储驱动程序的唯一要求。</p><p>该文档推荐了一种在Kubernetes部署任意容器化CSI驱动程序的标准机制。存储提供商可以使用它来简化Kubernetes上容器化CSI兼容卷驱动程序的部署(参见下面的“Kubernetes上部署CSI驱动程序的推荐机制”一节)。然而，这个机制是严格可选的。</p><h3 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h3><h4 id="Kubelet-到-CSI驱动"><a href="#Kubelet-到-CSI驱动" class="headerlink" title="Kubelet 到 CSI驱动"></a>Kubelet 到 CSI驱动</h4><p>Kubelet(负责装载和卸载)将通过Unix域套接字与运行在同一主机(无论是否容器化)上的外部“CSI卷(Volume)驱动程序”通信。</p><p>CSI卷(Volume)驱动程序应该在节点机器上的以下路径上创建一个套接字：<code>/var/lib/kubelet/plugins/[SanitizedCSIDriverName]/csi.sock</code>。对于alpha版本的实现, kubelet将假定这是Unix Domain Socket与CSI卷驱动程序通信的位置。对于beta版的实现，我们可以考虑使用<a href="/contributors/design-proposals/resource-management/device-plugin.md#unix-socket">Device Plugin Unix Domain Socket Registration</a>向kubelet注册Unix Domain Socket。这个机制需要扩展，以独立地支持CSI卷驱动程序和设备插件的注册。</p><p><code>Sanitized CSIDriverName</code>是CSI驱动程序名，不包含危险字符，可以用作注释名。它可以遵循我们在<a href="https://git.k8s.io/kubernetes/pkg/util/strings/escape.go#L27" target="_blank" rel="noopener">volume plugins</a>.中使用的相同模式。太长或难看的驱动程序名可以被拒绝使用，也就是说，所有在这个文档中描述的组件将报告一个错误，不会与这个CSI驱动程序通信。使用简洁驱动名名称是实施细则(最坏情况下为SHA)。</p><p>在外部“CSI卷驱动程序”初始化之后，kubelet必须调用CSI方法<code>NodeGetInfo</code>来获得从Kubernetes节点名到CSI驱动程序<code>NodeID</code>和相关的<code>accessible_topology</code>的映射。它必须:</p><ul><li><p>使用<code>accessible_topology</code>中的<code>NodeID</code>和拓扑键为节点创建/更新一个<code>CSINodeInfo</code>对象实例。</p><ul><li>这将允许发出<code>ControllerPublishVolume</code>调用的组件使用<code>CSINodeInfo</code>作为从集群节点ID到存储节点ID的映射。</li><li>这将使发出<code>CreateVolume</code>的组件能够重构<code>accessible_topology</code>，并提供来自特定节点的可访问卷。</li><li>每个驱动程序必须完全覆盖它以前版本的<code>NodeID</code>和拓扑键(如果它们存在的话)。</li><li>如果<code>NodeGetInfo</code>调用失败，kubelet必须删除此驱动程序之前的所有<code>NodeID</code>和拓扑键。</li><li>当kubelet插件取消注册机制被实现时，当驱动程序取消注册时，删除<code>NodeID</code>和拓扑密钥。</li></ul></li><li><p>以CSI驱动程序<code>NodeID</code>作为更新节点API对象<code>csi.volume.kubernetes.io/nodeid</code>注解的值。注解的值是一个JSON对象，包含每个CSI驱动程序的键/值对。例如: <code>csi.volume.kubernetes.io/nodeid: &quot;{ \&quot;driver1\&quot;: \&quot;name1\&quot;, \&quot;driver2\&quot;: \&quot;name2\&quot; }</code><br>此注释已被弃用，将根据弃用策略(弃用后1年)删除。TODO标记弃用日期。</p><ul><li>如果<code>NodeGetInfo</code>调用失败，kubelet必须删除此驱动程序之前的任何<code>NodeID</code>。</li><li>当kubelet插件取消注册机制实现时，当驱动程序取消注册时，删除<code>NodeID</code>和拓扑密钥。</li></ul></li><li><p>使用<code>accessible_topology</code>作为标签创建/更新节点API对象。标签格式没有硬性限制，但是对于推荐设置使用的格式，请查看<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#topology-representation-in-node-objects" target="_blank" rel="noopener">Topology Representation in Node Objects</a>。</p></li></ul><p>为了方便部署外部容器化的CSI卷驱动程序，Kubernetes团队将提供一个边车(sidecar)“Kubernetes CSI助手”容器，该容器可以管理UDS(unix domain socket)注册和<code>NodeID</code>初始化。下面的“在Kubernetes上部署CSI驱动程序的建议机制”小节对此进行了详细说明。</p><p>新的API对象<code>CSINodeInfo</code>将被定义如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CSINodeInfo holds information about status of all CSI drivers installed on a node.</span></span><br><span class="line"><span class="keyword">type</span> CSINodeInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    metav1.TypeMeta</span><br><span class="line">    <span class="comment">// ObjectMeta.Name must be node name.</span></span><br><span class="line">    metav1.ObjectMeta</span><br><span class="line"></span><br><span class="line">    <span class="comment">// List of CSI drivers running on the node and their properties.</span></span><br><span class="line">    CSIDrivers []CSIDriverInfo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Information about one CSI driver installed on a node.</span></span><br><span class="line"><span class="keyword">type</span> CSIDriverInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// CSI driver name.</span></span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ID of the node from the driver point of view.</span></span><br><span class="line">    NodeID <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Topology keys reported by the driver on the node.</span></span><br><span class="line">    TopologyKeys []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择新的对象类型<code>CSINodeInfo</code>替代<code>Node.Status</code>，因为Node对象已经足够大了与它的大小有问题有关。<code>CSINodeInfo</code>是在集群启动时由TODO (jsafrane)安装的CRD，在<code>kubernetes/kubernetes/pkg/apis/storage-csi/v1alpha1/types.go</code>中定义, 因此k8s.io/client-go和k8s.io/api自动生成。<code>CSINodeInfo</code>的所有用户将容忍如果CRD没有安装和重试任何他们需要做的指数后退和正确的错误报告。特别是当CRD缺失时，kubelet能够履行它的正常职责。</p><p>每个节点必须有0个或一个<code>CSINodeInfo</code>实例。这是由<code>CSINodeInfo.Name=Node.Name</code>名称。TODO:如何验证这个?每个<code>CSINodeInfo</code>都归属相应的Node，用于垃圾收集。</p><h4 id="Master到CSI驱动通信"><a href="#Master到CSI驱动通信" class="headerlink" title="Master到CSI驱动通信"></a>Master到CSI驱动通信</h4><p>因为CSI卷驱动程序代码被认为是不可信的，所以可能不允许它在主机上运行。因此，Kube controller manager(负责创建、删除、附加和分离)不能通过UDS(Unix Domain Socket)与“CSI卷驱动程序”容器进行通信。相反，Kube controller manager管理器将通过Kubernetes API与外部“CSI卷驱动程序”通信。</p><p>更具体地说，一些外部组件必须代表外部CSI卷驱动程序监视Kubernetes API，并触发针对它的适当操作。这消除了在kube-controller-manager和CSI卷驱动程序之间发现和保护通道的问题。</p><p>在Kubernetes上轻松部署外部容器化的CSI卷驱动程序，而无需让驱动程序Kubernetes知道，Kubernetes将提供一个边车(sidecar)“Kubernetes to CSI”代理容器，该代理容器将监视Kubernetes API并触发针对“CSI卷驱动程序”容器的适当操作。下面的“在Kubernetes上部署CSI驱动程序的建议机制”小节对此进行了详细说明。</p><p>外部组件CSI卷驱动程序监视Kubernetes API处理配置、删除、附加和分离操作实现。</p><h5 id="配置和删除"><a href="#配置和删除" class="headerlink" title="配置和删除"></a>配置和删除</h5><p>配置和删除操作使用现有的<code>外部供应器机制</code>进行处理，其中代表外部CSI卷驱动程序监视Kubernetes API的外部组件将充当外部供应器。</p><p>简而言之，为了动态地提供一个新的CSI卷，集群管理员将创建一个<code>StorageClass</code>，其中的供应者与代表CSI卷驱动程序处理供应请求的外部供应者的名称对应。</p><p>为了提供一个新的CSI卷，终端用户将创建一个引用这个存储类的<code>PersistentVolumeClaim</code>对象。外部供应程序将对PVC的创建做出反应，并发出针对CSI卷驱动程序的<code>CreateVolume</code>调用来供应卷。与其他动态供应的卷一样，<code>CreateVolume</code>名称将自动生成。<code>CreateVolume</code>能力将从<code>PersistentVolumeClaim</code>对象中获取。<code>CreateVolume</code>参数将通过<code>StorageClass</code>参数传递(对Kubernetes不透明)。</p><p>如果<code>PersistentVolumeClaim</code>的卷名是<code>volume.alpha.kubernetes.io/selected-node</code>注解(只有在<code>StorageClass</code>中启用延迟卷绑定时才添加)，供应者将从相应的<code>CSINodeInfo</code>实例中获取相关的拓扑键和节点标签中的拓扑值，并使用它们在<code>CreateVolume()</code>请求中生成首选拓扑。如果未设置注解，则不会指定首选拓扑(除非PVC遵循本节后面讨论的<code>StatefulSet</code>命名格式)。来自<code>StorageClass</code>的<code>allowedtopology</code>作为必需的拓扑传递。如果<code>AllowedTopologies</code>是未指定的，则供应程序将在整个集群中传递一组聚合的拓扑值作为必需的拓扑。</p><p>要执行此拓扑聚合，外部供应程序将缓存所有现有节点对象。为了防止受影响的节点影响供应过程，它将选择单个节点作为密钥的真值来源，而不是依赖于存储在<code>CSINodeInfo</code>中的密钥来获取每个节点对象。对于使用后期绑定提供的pvc，所选节点是事实的来源;否则将选择一个随机节点。然后，供应者将遍历包含来自驱动程序的节点ID的所有缓存节点，使用这些键聚合标签。注意，如果集群中的拓扑键不同，则只会考虑与所选节点的拓扑键匹配的节点子集进行供应。</p><p>为了生成首选拓扑，外部供应程序将在<code>CreateVolume()</code>调用中为首选拓扑生成N个段，其中N是必需拓扑的大小。包含多个段来支持跨多个拓扑段可用的卷。来自所选节点的拓扑段总是首选拓扑中的第一个。所有其他段都是对其余必要拓扑的一些重新排序，这样，对于给定的必要拓扑(或任意对其重新排序)和选择的节点，可以保证首选拓扑集总是相同的。</p><p>如果设置了即时卷绑定模式，并且PVC遵循状态集命名格式，那么供应程序将选择一个来自必需的基于PVC名称的拓扑的段作为首选拓扑中的第一个段，这将确保拓扑在状态集的所有卷中均匀分布。该逻辑与GCE持久磁盘供应程序中的名称哈希逻辑类似。优先拓扑中的其他段的顺序与上面描述的相同。这个特性将在作为推荐部署方法的一部分提供的外部供应程序中标记门控。</p><p>一旦操作成功完成，外部供应程序将创建一个<code>PersistentVolume</code>对象，使用<code>CreateVolume</code>响应中返回的信息来表示该卷。返回卷的拓扑被转换为<code>PersistentVolume</code> <code>NodeAffinity</code>字段。然后将<code>PersistentVolume</code>对象绑定到<code>PersistentVolumeClaim</code>并可供使用。</p><p>拓扑密钥/值对的格式由用户定义，并且必须在以下位置之间匹配:</p><ul><li><code>Node</code>拓扑标签</li><li><code>PersistentVolume</code> <code>NodeAffinity</code> 字段</li><li>当<code>StorageClass</code>启用了延迟卷绑定时，调度器将以以下方式使用节点的拓扑信息:<ol><li>在动态供应期间，调度器通过将每个节点的拓扑与<code>StorageClass</code>中的<code>AllowedTopologies</code>进行比较，为供应程序选择一个候选节点。</li><li>在卷绑定和pod调度期间，调度器通过比较<code>PersistentVolume</code>的<code>Node</code>拓扑和<code>VolumeNodeAffinity</code>来为pod选择一个候选节点。</li></ol></li></ul><p>更详细的描述可以在<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/volume-topology-scheduling.md" target="_blank" rel="noopener">topology-aware volume scheduling design doc</a>中找到。有关推荐部署方法使用的格式，请参阅<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#topology-representation-in-node-objects" target="_blank" rel="noopener">Topology Representation in Node Objects</a>。</p><p>要删除CSI卷，最终用户将删除相应的<code>PersistentVolumeClaim</code>对象。外部供应程序将对PVC的删除做出反应，并且基于其回收策略，它将针对CSI卷驱动程序命令发出<code>DeleteVolume</code>调用来删除卷。然后它将删除<code>PersistentVolume</code>对象。</p><h5 id="附加和分离"><a href="#附加和分离" class="headerlink" title="附加和分离"></a>附加和分离</h5><p>附加/分离操作也必须由外部组件(“attacher”)处理。attacher代表外部CSI卷驱动程序监视Kubernetes API，以获取新的<code>VolumeAttachment</code>对象(在下文中定义)，并触发针对CSI卷驱动程序的适当调用来附加卷。即使底层的CSI驱动程序不支持<code>ControllerPublishVolume</code>调用，因为Kubernetes对此一无所知，attacher也必须监视<code>VolumeAttachment</code>对象并将其标记为attached。</p><p>更具体地说，外部“attacher”必须代表外部CSI卷驱动程序监视Kubernetes API，以处理附加/分离请求。</p><p>一旦下列条件为真，外部提供者应该针对CSI卷驱动程序调用<code>ControllerPublishVolume</code>来将卷附加到指定的节点:</p><ol><li><p>由Kubernetes attach/detach控制器创建一个新的<code>VolumeAttachment</code>Kubernetes API对象。</p></li><li><p><code>VolumeAttachment.Spec.Attacher</code>值对应于外部Attacher的名称。</p></li><li><p><code>VolumeAttachment.Status.Attached</code>尚未设置为true。</p></li><li><ul><li><p>Kubernetes节点API对象的名称与<code>VolumeAttachment.Spec.NodeName</code>匹配。节点名和该对象包含一个<code>csi.volume.kubernetes.io/nodeid</code>注解。该注释包含一个JSON blob，一个键/值对列表，其中一个键对应CSI卷驱动程序名称，该值是该驱动程序的NodeID。这个NodeId映射可以在<code>ControllerPublishVolume</code>调用中检索和使用。</p></li><li><p>或者存在一个<code>CSINodeInfo</code> API对象，其名称与<code>VolumeAttachment.Spec.NodeName</code>匹配。节点名和对象包含CSI卷驱动程序的<code>CSIDriverInfo</code>。<code>CSIDriverInfo</code>包含<code>ControllerPublishVolume</code>调用的<code>NodeId</code>。</p></li></ul></li><li><p><code>VolumeAttachment.Metadata.DeletionTimestamp</code>没有设置。</p></li></ol><p>在启动<code>ControllerPublishVolume</code>操作之前， external-attacher应该将一下添加到这些Kubernetes API对象中:</p><ul><li><code>VolumeAttachment</code>，以便在删除对象时，external-attacher有机会首先分离卷。一旦卷与节点完全分离，external-attacher将删除该终结器。</li><li>到<code>VolumeAttachment</code>引用的持久卷，因此在附加卷时不能删除PV。外部连接器需要来自PV的信息来执行分离操作。一旦所有引用PV的<code>VolumeAttachment</code>对象被删除，即该卷与所有节点分离，则attacher将删除终结器。</li></ul><p>如果操作成功完成，<code>external-attacher</code>将:</p><ol><li>设置<code>VolumeAttachment.Status.Attached</code>为true以指示附加的卷。</li><li>更新<code>VolumeAttachment.Status.AttachmentMetadata</code>相应的内容并返回<code>PublishVolumeInfo</code>。</li><li>清除<code>VolumeAttachment.Status.AttachError</code>错误字段</li></ol><p>如果操作失败，<code>external-attacher</code>将:</p><ol><li>确保<code>VolumeAttachment.Status.Attached</code>为false，以表示没有附加成功。</li><li>设置<code>VolumeAttachment.Status.AttachError</code>为详细错误内容。</li><li>创建一个针对与<code>VolumeAttachment</code>对象关联的Kubernetes API的事件，以通知用户哪里出错了。</li></ol><p>external-attacher可以实现自己的错误恢复策略，并在上面为附件指定的条件有效时重试。强烈建议外部连接器对重试执行指数回退策略。</p><p>删除<code>VolumeAttachment</code> Kubernetes API对象将触发分离操作。因为<code>VolumeAttachment</code> Kubernetes API对象将有一个由external-attacher添加的终结器，所以它将在删除对象之前等待external-attacher的确认。</p><p>一旦所有的条件都为真，external-attacher应该针对CSI卷驱动程序调用<code>ControllerUnpublishVolume</code>来将卷从指定的节点分离出来:</p><ul><li><code>VolumeAttachment</code> Kubernetes API对象被标记为删除:设置了<code>VolumeAttachment.metadata.deletionTimestamp</code>字段的值。</li></ul><p>如果操作成功完成，<code>external-attacher</code>将:</p><ol><li>从<code>VolumeAttachment</code>对象上的终结器列表中删除其终结器，允许删除操作继续。</li></ol><p>如果操作失败，<code>external-attacher</code>将:</p><ol><li>确保<code>VolumeAttachment.Status.Attached</code>为false，以表示没有附加成功。</li><li>设置<code>VolumeAttachment.Status.AttachError</code>为详细错误内容。</li><li>创建一个针对与<code>VolumeAttachment</code>对象关联的Kubernetes API的事件，以通知用户哪里出错了。</li></ol><p>新的API对象<code>VolumeAttachment</code>将被定义如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VolumeAttachment captures the intent to attach or detach the specified volume</span></span><br><span class="line"><span class="comment">// to/from the specified node.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// VolumeAttachment objects are non-namespaced.</span></span><br><span class="line"><span class="keyword">type</span> VolumeAttachment <span class="keyword">struct</span> &#123;</span><br><span class="line">  metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Standard object metadata.</span></span><br><span class="line">  <span class="comment">// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata</span></span><br><span class="line">  <span class="comment">// +optional</span></span><br><span class="line">  metav1.ObjectMeta <span class="string">`json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Specification of the desired attach/detach volume behavior.</span></span><br><span class="line">  <span class="comment">// Populated by the Kubernetes system.</span></span><br><span class="line">  Spec VolumeAttachmentSpec <span class="string">`json:"spec" protobuf:"bytes,2,opt,name=spec"`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Status of the VolumeAttachment request.</span></span><br><span class="line">  <span class="comment">// Populated by the entity completing the attach or detach</span></span><br><span class="line">  <span class="comment">// operation, i.e. the external-attacher.</span></span><br><span class="line">  <span class="comment">// +optional</span></span><br><span class="line">  Status VolumeAttachmentStatus <span class="string">`json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The specification of a VolumeAttachment request.</span></span><br><span class="line"><span class="keyword">type</span> VolumeAttachmentSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// Attacher indicates the name of the volume driver that MUST handle this</span></span><br><span class="line">  <span class="comment">// request. This is the name returned by GetPluginName() and must be the</span></span><br><span class="line">  <span class="comment">// same as StorageClass.Provisioner.</span></span><br><span class="line">  Attacher <span class="keyword">string</span> <span class="string">`json:"attacher" protobuf:"bytes,1,opt,name=attacher"`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// AttachedVolumeSource represents the volume that should be attached.</span></span><br><span class="line">  VolumeSource AttachedVolumeSource <span class="string">`json:"volumeSource" protobuf:"bytes,2,opt,name=volumeSource"`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Kubernetes node name that the volume should be attached to.</span></span><br><span class="line">  NodeName <span class="keyword">string</span> <span class="string">`json:"nodeName" protobuf:"bytes,3,opt,name=nodeName"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VolumeAttachmentSource represents a volume that should be attached.</span></span><br><span class="line"><span class="comment">// Right now only PersistentVolumes can be attached via external attacher,</span></span><br><span class="line"><span class="comment">// in future we may allow also inline volumes in pods.</span></span><br><span class="line"><span class="comment">// Exactly one member can be set.</span></span><br><span class="line"><span class="keyword">type</span> AttachedVolumeSource <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// Name of the persistent volume to attach.</span></span><br><span class="line">  <span class="comment">// +optional</span></span><br><span class="line">  PersistentVolumeName *<span class="keyword">string</span> <span class="string">`json:"persistentVolumeName,omitempty" protobuf:"bytes,1,opt,name=persistentVolumeName"`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Placeholder for *VolumeSource to accommodate inline volumes in pods.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The status of a VolumeAttachment request.</span></span><br><span class="line"><span class="keyword">type</span> VolumeAttachmentStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// Indicates the volume is successfully attached.</span></span><br><span class="line">  <span class="comment">// This field must only be set by the entity completing the attach</span></span><br><span class="line">  <span class="comment">// operation, i.e. the external-attacher.</span></span><br><span class="line">  Attached <span class="keyword">bool</span> <span class="string">`json:"attached" protobuf:"varint,1,opt,name=attached"`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Upon successful attach, this field is populated with any</span></span><br><span class="line">  <span class="comment">// information returned by the attach operation that must be passed</span></span><br><span class="line">  <span class="comment">// into subsequent WaitForAttach or Mount calls.</span></span><br><span class="line">  <span class="comment">// This field must only be set by the entity completing the attach</span></span><br><span class="line">  <span class="comment">// operation, i.e. the external-attacher.</span></span><br><span class="line">  <span class="comment">// +optional</span></span><br><span class="line">  AttachmentMetadata <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="string">`json:"attachmentMetadata,omitempty" protobuf:"bytes,2,rep,name=attachmentMetadata"`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The most recent error encountered during attach operation, if any.</span></span><br><span class="line">  <span class="comment">// This field must only be set by the entity completing the attach</span></span><br><span class="line">  <span class="comment">// operation, i.e. the external-attacher.</span></span><br><span class="line">  <span class="comment">// +optional</span></span><br><span class="line">    AttachError *VolumeError <span class="string">`json:"attachError,omitempty" protobuf:"bytes,3,opt,name=attachError,casttype=VolumeError"`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The most recent error encountered during detach operation, if any.</span></span><br><span class="line">  <span class="comment">// This field must only be set by the entity completing the detach</span></span><br><span class="line">  <span class="comment">// operation, i.e. the external-attacher.</span></span><br><span class="line">  <span class="comment">// +optional</span></span><br><span class="line">  DetachError *VolumeError <span class="string">`json:"detachError,omitempty" protobuf:"bytes,4,opt,name=detachError,casttype=VolumeError"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Captures an error encountered during a volume operation.</span></span><br><span class="line"><span class="keyword">type</span> VolumeError <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// Time the error was encountered.</span></span><br><span class="line">  <span class="comment">// +optional</span></span><br><span class="line">  Time metav1.Time <span class="string">`json:"time,omitempty" protobuf:"bytes,1,opt,name=time"`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// String detailing the error encountered during Attach or Detach operation.</span></span><br><span class="line">  <span class="comment">// This string may be logged, so it should not contain sensitive</span></span><br><span class="line">  <span class="comment">// information.</span></span><br><span class="line">  <span class="comment">// +optional</span></span><br><span class="line">  Message <span class="keyword">string</span> <span class="string">`json:"message,omitempty" protobuf:"bytes,2,opt,name=message"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在Kubernetes上部署CSI驱动程序的推荐机制"><a href="#在Kubernetes上部署CSI驱动程序的推荐机制" class="headerlink" title="在Kubernetes上部署CSI驱动程序的推荐机制"></a>在Kubernetes上部署CSI驱动程序的推荐机制</h2><p>虽然Kubernetes并没有规定CSI卷驱动程序的打包，但是它提供了以下建议来简化在Kubernetes上部署容器化CSI卷驱动程序。<br><img src="container-storage-interface_diagram1.png?raw=true" alt="Recommended CSI Deployment Diagram" title="Recommended CSI Deployment Diagram"></p><p>要部署一个容器化的第三方CSI卷驱动程序，建议存储供应商:</p><ul><li><p>创建一个“CSI卷驱动程序”容器，该容器实现卷插件行为，并通过UDS(unix domain socket)公开gRPC接口，如CSI规范中定义的那样(包括控制器(Controller Service)、节点服务(Node Service)和身份服务(Identity Service))。</p></li><li><p>绑定“CSI卷驱动程序”容器辅助容器(external-attacher、external-provisioner node-driver-registrar, cluster-driver-registrar, external-resizer, external-snapshotter, livenessprobe) Kubernetes团队将提供(这些辅助容器将协助“CSI卷驱动程序”容器与Kubernetes交互系统)。更具体地说，创建以下Kubernetes对象:</p><ul><li>为了方便与Kubernetes控制器、<code>StatefulSet</code>或<code>Deployment</code>(根据用户的需要，参见集群级部署)有：<ul><li>提供以下容器：<ul><li>“CSI卷驱动程序”容器有存储提供商提供。</li><li>Kubernetes团队提供的容器(都是可选的):<ul><li><code>cluster-driver-registrar</code> (请参考“cluster-driver-registrar”存储库中的描述，必须的)</li><li><code>external-provisioner</code> (必须， 提供 provision/delete 操作)</li><li><code>external-attacher</code> (必须， 提供attach/detach 操作. 如果您希望跳过附加步骤，除了忽略此容器外，还必须在Kubernetes中启用CSISkipAttach特性)</li><li><code>external-resizer</code> (必须， 提供resize操作)</li><li><code>external-snapshotter</code> (必须，提供volume-level快照操作)</li><li><code>livenessprobe</code></li></ul></li></ul></li><li>提供以下容器:<ul><li><code>emptyDir</code> 卷</li><li>挂载所有的容器,包括 “CSI卷驱动程序”.</li><li>“CSI卷驱动程序”容器应该在相应的目录中创建它的UDS，以便与Kubernetes帮助容器进行通信。</li></ul></li></ul></li><li>一个<code>DaemonSet</code>(为了方便与kubelet的每个实例进行通信)，它具有:<ul><li>提供以下容器<ul><li>“CSI卷驱动程序”容器有存储提供商提供。</li><li>Kubernetes团队提供的容器：<ul><li><code>node-driver-registrar</code> - 负责向kubelet注册UDS(unix domain socket)。</li><li><code>livenessprobe</code> (可选)</li></ul></li></ul></li><li>提供以下存储卷:<ul><li><code>hostpath</code>卷<ul><li>从主机中暴露<code>/var/lib/kubelet/plugins_registry</code>目录。</li><li>只在<code>node-driver-registrar</code>容器中挂载<code>/registration</code>目录。</li><li><code>node-driver-registrar</code> 将使用此UDS(unix domain socket)向kubelet<code>注册CSI驱动程序</code>的UDS(unix domain socket)。</li></ul></li><li><code>hostpath</code>卷<ul><li>从主机中暴露<code>/var/lib/kubelet/</code>目录.</li><li>只挂载<code>/var/lib/kubelet/</code>到<code>注册CSI驱动程</code>容器中。</li><li>确保 <a href="https://kubernetes.io/docs/concepts/storage/volumes/#mount-propagation" target="_blank" rel="noopener">bi-directional mount propagation</a> 特性启用了, 以便，此容器内的任何挂载设置都将传播回主机。</li></ul></li><li><code>hostpath</code>卷<ul><li>暴露主机目录<code>/var/lib/kubelet/plugins/[SanitizedCSIDriverName]/</code>并设置属性<code>hostPath.type = &quot;DirectoryOrCreate&quot;</code>.</li><li>在挂载<code>注册CSI驱动程序</code>容器的目录上CSI gRPC服务将被创建。</li><li>这是Kubelet和<code>CSI卷驱动程序</code>容器(通过UDS的GRPC)之间的主要通信手段。</li></ul></li></ul></li></ul></li></ul></li><li><p>让集群管理员部署上面的<code>StatefulSet</code>和<code>DaemonSet</code>来在Kubernetes集群中添加对存储系统的支持。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSI-Volume-Plugins-in-Kubernetes-Design-Doc&quot;&gt;&lt;a href=&quot;#CSI-Volume-Plugins-in-Kubernetes-Design-Doc&quot; class=&quot;headerlink&quot; title=&quot;CSI Volume Plugins in Kubernetes Design Doc&quot;&gt;&lt;/a&gt;CSI Volume Plugins in Kubernetes Design Doc&lt;/h2&gt;&lt;h2 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;解析&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Container Storage Interface (CSI)&lt;/td&gt;
&lt;td&gt;一种试图建立行业标准接口的规范，容器编排系统(COs)可以用来将任意存储系统暴露给它们的容器化工作负载。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in-tree&lt;/td&gt;
&lt;td&gt;Kubernetes 核心代码库中的代码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out-of-tree&lt;/td&gt;
&lt;td&gt;Kubernetes 核心代码库之外的代码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CSI Volume Plugin&lt;/td&gt;
&lt;td&gt;核心代码库中一个新的volume插件，用作适配器，支持第三方Kubernetes CSI volume驱动程序。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CSI Volume Driver&lt;/td&gt;
&lt;td&gt;第三方CSI插件驱动实现，可以用过CSI Volume Plugin在Kubernetes中使用。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://anywhy.xyz/categories/Kubernetes/"/>
    
    
      <category term="CSI" scheme="http://anywhy.xyz/tags/CSI/"/>
    
      <category term="storage" scheme="http://anywhy.xyz/tags/storage/"/>
    
      <category term="k8s" scheme="http://anywhy.xyz/tags/k8s/"/>
    
  </entry>
  
</feed>
